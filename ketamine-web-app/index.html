<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ketamine Question Bank</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <!-- PDF Generation Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    :root {
      --primary-color: #6a4c93;
      --primary-light: #8a6db1;
      --primary-dark: #4a2c73;
      --secondary-color: #73c2fb;
      --secondary-light: #93e2ff;
      --secondary-dark: #53a2db;
      --text-color: #333;
      --light-text: #f8f9fa;
      --background-color: #f8f9fa;
      --card-bg: #ffffff;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
    }

    .app-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
    }

    .header-content {
      text-align: left;
    }

    header h1 {
      color: var(--primary-color);
      margin-bottom: 0.5rem;
    }

    .subtitle {
      color: var(--text-color);
      font-weight: 300;
    }

    .header-actions {
      display: flex;
      gap: 1rem;
    }

    section {
      background-color: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 1.5rem;
      margin-bottom: 2rem;
    }

    .question-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    #current-question {
      text-align: center;
      font-size: 1.4rem;
      color: var(--primary-dark);
      margin-bottom: 1rem;
      min-height: 3.5rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: var(--transition);
    }

    .primary-btn {
      background-color: var(--primary-color);
      color: var(--light-text);
    }

    .primary-btn:hover {
      background-color: var(--primary-dark);
    }

    .secondary-btn {
      background-color: var(--secondary-color);
      color: var(--text-color);
    }

    .secondary-btn:hover {
      background-color: var(--secondary-dark);
    }

    .record-btn {
      background-color: #e74c3c;
      color: var(--light-text);
    }

    .record-btn:hover {
      background-color: #c0392b;
    }

    .record-btn.recording {
      background-color: #2ecc71;
    }

    .record-btn.recording:hover {
      background-color: #27ae60;
    }

    .ai-btn {
      background-color: #3498db;
      color: var(--light-text);
    }

    .ai-btn:hover {
      background-color: #2980b9;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .recording-indicator {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    #recording-status {
      font-weight: 500;
    }

    #recording-status.active {
      color: #e74c3c;
    }

    .audio-player {
      width: 100%;
      margin: 1rem 0;
    }

    audio {
      width: 100%;
    }

    .transcription-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    #transcription-text {
      width: 100%;
      min-height: 150px;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      font-family: 'Poppins', sans-serif;
      resize: vertical;
    }

    .followup-container {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f1f1f1;
      border-radius: var(--border-radius);
    }

    .followup-container h3 {
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    .export-section {
      display: flex;
      justify-content: center;
      gap: 1rem;
    }

    footer {
      text-align: center;
      margin-top: 2rem;
      color: #777;
      font-size: 0.9rem;
    }

    /* Session History */
    .session-history {
      position: fixed;
      top: 0;
      right: -400px;
      width: 380px;
      height: 100vh;
      background-color: var(--card-bg);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      transition: right 0.3s ease;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    .session-history.visible {
      right: 0;
    }

    .history-header {
      padding: 1.5rem;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .history-header h3 {
      margin: 0;
      color: var(--primary-color);
    }

    .history-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    .history-footer {
      padding: 1rem;
      border-top: 1px solid #eee;
      display: flex;
      justify-content: space-between;
    }

    .session-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .session-item {
      background-color: #f9f9f9;
      border-radius: var(--border-radius);
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition);
    }

    .session-item:hover {
      background-color: #f0f0f0;
    }

    .session-info h4 {
      margin: 0 0 0.5rem 0;
      color: var(--primary-dark);
    }

    .session-info p {
      margin: 0;
      font-size: 0.9rem;
      color: #666;
    }

    .session-actions {
      display: flex;
      gap: 0.5rem;
    }

    .small-btn {
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
    }

    .empty-message {
      text-align: center;
      color: #999;
      padding: 2rem 0;
    }
    
    /* Notes Panel */
    .notes-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 380px;
      height: 100vh;
      background-color: var(--card-bg);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      transition: right 0.3s ease;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    .notes-panel.visible {
      right: 0;
    }

    .notes-header {
      padding: 1.5rem;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .notes-header h3 {
      margin: 0;
      color: var(--primary-color);
    }
    
    .notes-search {
      padding: 1rem;
      border-bottom: 1px solid #eee;
      display: flex;
      gap: 0.5rem;
    }
    
    .search-input {
      flex: 1;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      font-family: 'Poppins', sans-serif;
    }

    .notes-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    .notes-footer {
      padding: 1rem;
      border-top: 1px solid #eee;
      display: flex;
      justify-content: space-between;
    }

    .notes-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .note-item {
      background-color: #f9f9f9;
      border-radius: var(--border-radius);
      padding: 1rem;
      transition: var(--transition);
    }

    .note-item:hover {
      background-color: #f0f0f0;
    }

    .note-item h4 {
      color: var(--primary-dark);
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .note-item p {
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }

    .note-item .note-date {
      font-size: 0.8rem;
      color: #666;
      font-style: italic;
      text-align: right;
      margin-top: 0.5rem;
    }

    .note-item .note-followup {
      margin-top: 0.5rem;
      padding-left: 0.5rem;
      border-left: 3px solid var(--primary-light);
      font-style: italic;
      color: var(--primary-dark);
    }

    .note-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .search-results-message {
      background-color: #e9f7fe;
      padding: 0.75rem;
      border-radius: var(--border-radius);
      margin-bottom: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Loading Indicator */
    .loading-indicator {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Toast Notifications */
    #toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1500;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .toast {
      min-width: 250px;
      max-width: 350px;
      background-color: white;
      color: #333;
      border-radius: var(--border-radius);
      padding: 1rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    .toast.show {
      transform: translateX(0);
    }

    .toast.success {
      border-left: 4px solid #2ecc71;
    }

    .toast.error {
      border-left: 4px solid #e74c3c;
    }

    .toast.info {
      border-left: 4px solid #3498db;
    }

    /* Recording Animation */
    .recording-pulse {
      display: inline-block;
      width: 12px;
      height: 12px;
      background-color: #e74c3c;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 1.5s infinite;
    }

    /* AI Follow-up Animation */
    .ai-thinking {
      display: inline-block;
      margin-left: 8px;
    }

    .ai-thinking span {
      display: inline-block;
      width: 8px;
      height: 8px;
      background-color: var(--primary-color);
      border-radius: 50%;
      margin-right: 4px;
      animation: bounce 1.4s infinite ease-in-out;
    }

    .ai-thinking span:nth-child(1) {
      animation-delay: 0s;
    }

    .ai-thinking span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .ai-thinking span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes bounce {
      0%, 80%, 100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-8px);
      }
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .app-container {
        padding: 1rem;
      }
      
      #current-question {
        font-size: 1.2rem;
      }
      
      .export-section {
        flex-direction: column;
        align-items: center;
      }
      
      .btn {
        width: 100%;
        justify-content: center;
      }

      header {
        flex-direction: column;
        gap: 1rem;
      }
      
      .header-content {
        text-align: center;
      }
      
      .header-actions {
        width: 100%;
        justify-content: center;
      }

      .session-history {
        width: 100%;
        right: -100%;
      }
      
      .history-footer {
        flex-direction: column;
        gap: 0.5rem;
      }
      
      .history-footer button {
        width: 100%;
      }
      
      .session-item {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .session-actions {
        margin-top: 1rem;
        width: 100%;
        justify-content: flex-end;
      }
    }

    /* Accessibility */
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    
    /* Note Section Styles */
    .note-section {
      margin-top: 1rem;
    }
    
    .note-preview {
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      padding: 1.5rem;
      margin-top: 1rem;
    }
    
    .note-content {
      white-space: pre-wrap;
      font-family: 'Poppins', sans-serif;
      line-height: 1.6;
    }
    
    .note-content h4 {
      color: var(--primary-color);
      margin-bottom: 0.5rem;
    }
    
    .note-content p {
      margin-bottom: 1rem;
    }
    
    .note-content .followup {
      color: var(--primary-dark);
      font-style: italic;
      margin-top: 1rem;
      border-left: 3px solid var(--primary-light);
      padding-left: 1rem;
    }
    
    .copy-success {
      background-color: #d4edda;
      color: #155724;
      padding: 0.5rem;
      border-radius: var(--border-radius);
      margin-top: 1rem;
      text-align: center;
      display: none;
    }
  </style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
  <div class="app-container">
    <header>
      <div class="header-content">
        <h1>Ketamine Therapy Question Bank</h1>
        <p class="subtitle">Record, transcribe, and save your reflections</p>
      </div>
      <div class="header-actions">
        <button id="history-btn" class="btn secondary-btn">
          <i class="fas fa-history"></i> Session History
        </button>
        <button id="notes-btn" class="btn secondary-btn">
          <i class="fas fa-sticky-note"></i> View Notes
        </button>
      </div>
    </header>

    <main>
      <section class="question-section">
        <div class="question-container">
          <h2 id="current-question">Click "New Question" to begin</h2>
          <button id="new-question-btn" class="btn primary-btn">
            <i class="fas fa-random"></i> New Question
          </button>
        </div>
      </section>

      <section class="recording-section">
        <div class="controls">
          <button id="record-btn" class="btn record-btn" disabled>
            <i class="fas fa-microphone"></i> Start Recording
          </button>
          <div class="recording-indicator">
            <span id="recording-status">Not Recording</span>
            <span id="recording-time">00:00</span>
          </div>
        </div>
        <div class="audio-player">
          <audio id="audio-playback" controls></audio>
        </div>
      </section>

      <section class="transcription-section">
        <h3>Your Response</h3>
        <div class="transcription-container">
          <textarea id="transcription-text" placeholder="Your response will appear here after recording, or you can type directly..."></textarea>
          <button id="edit-transcription-btn" class="btn secondary-btn">
            <i class="fas fa-edit"></i> Edit Response
          </button>
        </div>
      </section>

      <section class="ai-followup-section">
        <button id="ai-followup-btn" class="btn ai-btn" disabled>
          <i class="fas fa-brain"></i> Generate AI Follow-up
        </button>
        <div class="followup-container">
          <h3>AI Follow-up Question</h3>
          <p id="followup-text">AI follow-up question will appear here after generation...</p>
        </div>
      </section>

      <section class="export-section">
        <button id="export-pdf-btn" class="btn primary-btn" disabled>
          <i class="fas fa-file-pdf"></i> Export to PDF
        </button>
        <button id="save-session-btn" class="btn secondary-btn" disabled>
          <i class="fas fa-save"></i> Save Session
        </button>
        <button id="copy-note-btn" class="btn secondary-btn" disabled>
          <i class="fas fa-copy"></i> Copy as Note
        </button>
      </section>
      
      <section class="note-section" style="display: none;">
        <h3>Formatted Note</h3>
        <div class="note-preview">
          <div id="note-content" class="note-content"></div>
        </div>
      </section>
    </main>

    <footer>
      <p>Created for personal reflection and therapy support</p>
    </footer>

    <!-- Session History Panel -->
    <div id="session-history" class="session-history">
      <div class="history-header">
        <h3>Session History</h3>
        <button id="close-history-btn" class="btn secondary-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="history-content">
        <div id="session-list" class="session-list">
          <p class="empty-message">No saved sessions found.</p>
        </div>
      </div>
      <div class="history-footer">
        <button id="export-all-btn" class="btn secondary-btn">
          <i class="fas fa-download"></i> Export All Sessions
        </button>
        <button id="import-sessions-btn" class="btn secondary-btn">
          <i class="fas fa-upload"></i> Import Sessions
        </button>
      </div>
    </div>
    
    <!-- Notes Panel -->
    <div id="notes-panel" class="notes-panel">
      <div class="notes-header">
        <h3>Saved Notes</h3>
        <button id="close-notes-btn" class="btn secondary-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="notes-search">
        <input type="text" id="notes-search-input" placeholder="Search notes..." class="search-input">
        <button id="notes-search-btn" class="btn secondary-btn">
          <i class="fas fa-search"></i>
        </button>
      </div>
      <div class="notes-content">
        <div id="notes-list" class="notes-list">
          <p class="empty-message">No saved notes found.</p>
        </div>
      </div>
      <div class="notes-footer">
        <button id="export-notes-btn" class="btn secondary-btn">
          <i class="fas fa-download"></i> Export All Notes
        </button>
        <button id="import-notes-btn" class="btn secondary-btn">
          <i class="fas fa-upload"></i> Import Notes
        </button>
        <button id="clear-notes-btn" class="btn secondary-btn">
          <i class="fas fa-trash"></i> Clear All Notes
        </button>
      </div>
    </div>
  </div>

  <script>
    // Question Bank
    const questionBank = [
      "What thoughts or worries come up for you in the mornings?",
      "Are there specific situations or tasks you anticipate that might be contributing to your anxiety?",
      "How does your body feel when you wake up?",
      "Have you noticed any patterns or triggers that worsen your morning anxiety?",
      "What activities or practices have helped you manage anxiety in the past?",
      "If your anxiety had a voice, what would it be saying?",
      "What's the very first thing you notice about your body when you wake up?",
      "If your anxiety had a color, what would it be?",
      "What does your anxiety feel like in your body?",
      "If you could talk to your anxiety, what would you say?",
      "What does your anxiety want you to know?",
      "Is there a younger version of yourself that needs comfort or reassurance?",
      "What would it feel like to let go of this anxiety, even for a moment?",
      "If you could offer your anxiety some compassion, what would that look like?",
      "Can you identify any positive intentions behind your anxiety?",
      "Imagine your anxiety as a cloud passing through the sky. Can you observe it without judgment?",
      "If you could create a safe space for yourself, where would it be?",
      "What are you most afraid would happen if you weren't anxious?",
      "If you could give your anxiety a name, what would it be?",
      "What is your anxiety trying to protect you from?",
      "When in your life did you first experience this feeling?",
      "When you notice the anxiety rising, what thoughts are present in your mind?",
      "What stories do you tell yourself about the anxiety and its causes?",
      "If you were to write down every thought you're having right now, what would they be?"
    ];

    // DOM Elements
    const currentQuestionEl = document.getElementById('current-question');
    const newQuestionBtn = document.getElementById('new-question-btn');
    const recordBtn = document.getElementById('record-btn');
    const recordingStatus = document.getElementById('recording-status');
    const recordingTime = document.getElementById('recording-time');
    const audioPlayback = document.getElementById('audio-playback');
    const transcriptionText = document.getElementById('transcription-text');
    const editTranscriptionBtn = document.getElementById('edit-transcription-btn');
    const aiFollowupBtn = document.getElementById('ai-followup-btn');
    const followupText = document.getElementById('followup-text');
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    const saveSessionBtn = document.getElementById('save-session-btn');
    const historyBtn = document.getElementById('history-btn');
    const sessionHistoryPanel = document.getElementById('session-history');
    const closeHistoryBtn = document.getElementById('close-history-btn');
    const sessionList = document.getElementById('session-list');
    const exportAllBtn = document.getElementById('export-all-btn');
    const importSessionsBtn = document.getElementById('import-sessions-btn');

    // Application State
    const state = {
      currentQuestion: null,
      recording: false,
      mediaRecorder: null,
      audioChunks: [],
      audioBlob: null,
      audioUrl: null,
      transcription: '',
      followupQuestion: '',
      recordingStartTime: null,
      recordingTimer: null,
      sessionData: {
        questions: [],
        responses: [],
        followups: []
      },
      sessionHistory: {
        visible: false,
        sessions: []
      },
      notes: {
        visible: false,
        items: []
      }
    };

    // Initialize the application
    function init() {
      // Check for browser compatibility
      if (!checkBrowserCompatibility()) {
        return;
      }
      
      // Set up event listeners
      setupEventListeners();
      
      // Load saved sessions
      loadSavedSessions();
      
      // Load saved notes
      state.notes.items = getAllNotes();
      
      // Update notes button to show count
      updateNotesButtonCount();
      
      // Show welcome message
      showWelcomeMessage();

      // Enable direct typing in the transcription area
      transcriptionText.readOnly = false;
      editTranscriptionBtn.disabled = false;
    }
    
    // Update notes button to show count
    function updateNotesButtonCount() {
      const notesBtn = document.getElementById('notes-btn');
      const noteCount = state.notes.items.length;
      
      if (noteCount > 0) {
        notesBtn.innerHTML = `<i class="fas fa-sticky-note"></i> View Notes (${noteCount})`;
      } else {
        notesBtn.innerHTML = `<i class="fas fa-sticky-note"></i> View Notes`;
      }
    }

    // Check if browser supports required APIs
    function checkBrowserCompatibility() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showErrorMessage('Your browser does not support audio recording. You can still use the application to type responses manually.');
        // Disable recording button
        recordBtn.disabled = true;
        recordBtn.title = "Recording not supported in this browser";
        return true; // Still allow usage without recording
      }
      
      return true;
    }

    // Set up event listeners for all interactive elements
    function setupEventListeners() {
      // New Question Button
      newQuestionBtn.addEventListener('click', getRandomQuestion);
      
      // Record Button
      recordBtn.addEventListener('click', toggleRecording);
      
      // Edit Transcription Button
      editTranscriptionBtn.addEventListener('click', focusTranscription);
      
      // AI Followup Button
      aiFollowupBtn.addEventListener('click', generateAIFollowup);
      
      // Export PDF Button
      exportPdfBtn.addEventListener('click', exportToPDF);
      
      // Save Session Button
      saveSessionBtn.addEventListener('click', saveSession);
      
      // Copy Note Button
      const copyNoteBtn = document.getElementById('copy-note-btn');
      copyNoteBtn.addEventListener('click', copyAsNote);
      
      // History Button
      historyBtn.addEventListener('click', toggleSessionHistory);
      
      // Close History Button
      closeHistoryBtn.addEventListener('click', hideSessionHistory);
      
      // Export All Button
      exportAllBtn.addEventListener('click', exportAllSessions);
      
      // Import Sessions Button
      importSessionsBtn.addEventListener('click', showImportDialog);
      
      // Notes Button
      const notesBtn = document.getElementById('notes-btn');
      notesBtn.addEventListener('click', toggleNotesPanel);
      
      // Close Notes Button
      const closeNotesBtn = document.getElementById('close-notes-btn');
      closeNotesBtn.addEventListener('click', hideNotesPanel);
      
      // Export Notes Button
      const exportNotesBtn = document.getElementById('export-notes-btn');
      exportNotesBtn.addEventListener('click', exportAllNotes);
      
      // Import Notes Button
      const importNotesBtn = document.getElementById('import-notes-btn');
      importNotesBtn.addEventListener('click', importNotes);
      
      // Clear Notes Button
      const clearNotesBtn = document.getElementById('clear-notes-btn');
      clearNotesBtn.addEventListener('click', clearAllNotes);
      
      // Notes Search
      const notesSearchInput = document.getElementById('notes-search-input');
      const notesSearchBtn = document.getElementById('notes-search-btn');
      
      notesSearchBtn.addEventListener('click', () => searchNotes(notesSearchInput.value));
      notesSearchInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
          searchNotes(notesSearchInput.value);
        }
      });

      // Enable AI follow-up and export when text is entered
      transcriptionText.addEventListener('input', function() {
        state.transcription = this.value;
        if (this.value.trim().length > 0) {
          aiFollowupBtn.disabled = false;
          exportPdfBtn.disabled = false;
          saveSessionBtn.disabled = false;
          copyNoteBtn.disabled = false;
        } else {
          aiFollowupBtn.disabled = true;
          exportPdfBtn.disabled = true;
          saveSessionBtn.disabled = true;
          copyNoteBtn.disabled = true;
        }
      });
    }

    // Show welcome message
    function showWelcomeMessage() {
      const welcomeMessage = `
        <div class="welcome-message">
          <h2>Welcome to Ketamine Therapy Question Bank</h2>
          <p>This application helps you explore and reflect on your thoughts and feelings during ketamine therapy sessions.</p>
          <p>Click "New Question" to begin your reflection journey.</p>
        </div>
      `;
      
      currentQuestionEl.innerHTML = welcomeMessage;
    }

    // Get a random question from the question bank
    function getRandomQuestion() {
      // Get a random index
      const randomIndex = Math.floor(Math.random() * questionBank.length);
      
      // Set the current question
      state.currentQuestion = questionBank[randomIndex];
      
      // Update the UI
      currentQuestionEl.textContent = state.currentQuestion;
      
      // Enable the record button if recording is supported
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        recordBtn.disabled = false;
      }
      
      // Reset the UI for a new question
      resetUI();
    }

    // Reset the UI for a new question
    function resetUI() {
      // Reset recording state
      state.recording = false;
      state.audioChunks = [];
      state.audioBlob = null;
      state.audioUrl = null;
      state.followupQuestion = '';
      
      // Reset UI elements
      recordBtn.innerHTML = '<i class="fas fa-microphone"></i> Start Recording';
      recordBtn.classList.remove('recording');
      recordingStatus.textContent = 'Not Recording';
      recordingStatus.classList.remove('active');
      recordingTime.textContent = '00:00';
      audioPlayback.src = '';
      audioPlayback.style.display = 'none';
      
      // Clear transcription but keep it editable
      transcriptionText.value = '';
      followupText.textContent = 'AI follow-up question will appear here after generation...';
      
      // Hide note section
      document.querySelector('.note-section').style.display = 'none';
      
      // Disable buttons that require a response
      aiFollowupBtn.disabled = true;
      exportPdfBtn.disabled = true;
      saveSessionBtn.disabled = true;
      document.getElementById('copy-note-btn').disabled = true;
    }

    // Toggle recording on/off
    async function toggleRecording() {
      if (!state.recording) {
        // Start recording
        await startRecording();
      } else {
        // Stop recording
        stopRecording();
      }
    }

    // Start audio recording
    async function startRecording() {
      try {
        // Request microphone access
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Create media recorder
        state.mediaRecorder = new MediaRecorder(stream);
        
        // Set up event handlers
        state.mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            state.audioChunks.push(event.data);
          }
        };
        
        state.mediaRecorder.onstop = processRecording;
        
        // Start recording
        state.mediaRecorder.start();
        state.recording = true;
        
        // Update UI
        recordBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Recording';
        recordBtn.classList.add('recording');
        recordingStatus.textContent = 'Recording...';
        recordingStatus.classList.add('active');
        
        // Add recording pulse animation
        const pulseElement = document.createElement('span');
        pulseElement.className = 'recording-pulse';
        recordingStatus.prepend(pulseElement);
        
        // Start recording timer
        startRecordingTimer();
        
      } catch (error) {
        console.error('Error starting recording:', error);
        showErrorMessage('Could not access microphone. Please ensure you have granted permission or type your response directly.');
      }
    }

    // Stop audio recording
    function stopRecording() {
      if (state.mediaRecorder && state.recording) {
        state.mediaRecorder.stop();
        state.recording = false;
        
        // Stop all audio tracks
        state.mediaRecorder.stream.getTracks().forEach(track => track.stop());
        
        // Stop recording timer
        stopRecordingTimer();
        
        // Update UI
        recordBtn.innerHTML = '<i class="fas fa-microphone"></i> Start Recording';
        recordBtn.classList.remove('recording');
        recordingStatus.textContent = 'Processing...';
        
        // Remove pulse element
        const pulseElement = recordingStatus.querySelector('.recording-pulse');
        if (pulseElement) {
          recordingStatus.removeChild(pulseElement);
        }
      }
    }

    // Process the recorded audio
    function processRecording() {
      // Create audio blob from chunks
      state.audioBlob = new Blob(state.audioChunks, { type: 'audio/webm' });
      
      // Create URL for audio playback
      state.audioUrl = URL.createObjectURL(state.audioBlob);
      
      // Update audio player
      audioPlayback.src = state.audioUrl;
      audioPlayback.style.display = 'block';
      
      // Update UI
      recordingStatus.textContent = 'Recording Complete';
      
      // Enable buttons
      aiFollowupBtn.disabled = false;
      exportPdfBtn.disabled = false;
      saveSessionBtn.disabled = false;
      
      // Attempt transcription if supported
      if (window.SpeechRecognition || window.webkitSpeechRecognition) {
        transcriptionText.value = "Transcription is not available in this web version. Please type your response manually.";
      } else {
        transcriptionText.value = "Please type your response here.";
      }
      
      // Focus on transcription for editing
      focusTranscription();
    }

    // Focus on the transcription textarea
    function focusTranscription() {
      transcriptionText.focus();
    }

    // Generate AI follow-up question
    function generateAIFollowup() {
      // Disable button during generation
      aiFollowupBtn.disabled = true;
      
      // Show loading indicator
      followupText.innerHTML = 'Generating follow-up question... <div class="ai-thinking"><span></span><span></span><span></span></div>';
      
      // Simulate API delay
      setTimeout(() => {
        // Generate a follow-up based on the current question
        const followups = {
          "What thoughts or worries come up for you in the mornings?": 
            "How do these morning thoughts affect the rest of your day?",
          
          "Are there specific situations or tasks you anticipate that might be contributing to your anxiety?": 
            "What would it feel like to approach these situations without the weight of anxiety?",
          
          "How does your body feel when you wake up?": 
            "Have you noticed any connection between your physical sensations upon waking and your emotional state?",
          
          "Have you noticed any patterns or triggers that worsen your morning anxiety?": 
            "What small change could you make to interrupt one of these patterns?",
          
          "What activities or practices have helped you manage anxiety in the past?": 
            "What prevents you from engaging in these helpful practices more consistently?",
          
          "If your anxiety had a voice, what would it be saying?": 
            "Where do you think those messages originally came from in your life?",
          
          "What's the very first thing you notice about your body when you wake up?": 
            "How might focusing on different physical sensations change your morning experience?",
          
          "If your anxiety had a color, what would it be?": 
            "If you could gradually transform this color into something more peaceful, what would that process look like?",
          
          "What does your anxiety feel like in your body?": 
            "When you feel this sensation, what do you typically do in response?",
          
          "If you could talk to your anxiety, what would you say?": 
            "What do you think your anxiety might say in response?",
          
          "What does your anxiety want you to know?": 
            "How might acknowledging this message change your relationship with your anxiety?",
          
          "Is there a younger version of yourself that needs comfort or reassurance?": 
            "What specific words or actions would be most comforting to this younger self?",
          
          "What would it feel like to let go of this anxiety, even for a moment?": 
            "What's one small step you could take toward experiencing that feeling more often?",
          
          "If you could offer your anxiety some compassion, what would that look like?": 
            "How might showing compassion to your anxiety change how it manifests in your life?",
          
          "Can you identify any positive intentions behind your anxiety?": 
            "How might you honor those intentions in a way that feels less distressing?",
          
          "Imagine your anxiety as a cloud passing through the sky. Can you observe it without judgment?": 
            "What happens to the intensity of your anxiety when you observe it this way?",
          
          "If you could create a safe space for yourself, where would it be?": 
            "What elements of this safe space could you incorporate into your daily environment?",
          
          "What are you most afraid would happen if you weren't anxious?": 
            "How might your life be different if this fear didn't hold such power?",
          
          "If you could give your anxiety a name, what would it be?": 
            "How might naming your anxiety change your relationship with it?",
          
          "What is your anxiety trying to protect you from?": 
            "Is this protection still necessary in your current life circumstances?",
          
          "When in your life did you first experience this feeling?": 
            "How has your relationship with this feeling evolved since then?",
          
          "When you notice the anxiety rising, what thoughts are present in your mind?": 
            "Which of these thoughts feels most powerful, and why do you think that is?",
          
          "What stories do you tell yourself about the anxiety and its causes?": 
            "How might reframing these stories impact your experience of anxiety?",
          
          "If you were to write down every thought you're having right now, what would they be?": 
            "Looking at these thoughts objectively, which ones are based on facts versus assumptions?"
        };
        
        // Get the follow-up for the current question or use a default
        state.followupQuestion = followups[state.currentQuestion] || 
          "How does exploring this question make you feel about your anxiety?";
        
        followupText.textContent = state.followupQuestion;
        
        // Re-enable button
        aiFollowupBtn.disabled = false;
        
      }, 1500);
    }

    // Export responses to PDF
    function exportToPDF() {
      // Save the current question and response
      saveCurrentData();
      
      try {
        // Check if jsPDF is available
        if (typeof window.jspdf === 'undefined') {
          exportAsText();
          return;
        }
        
        // Get the jsPDF instance
        const { jsPDF } = window.jspdf;
        
        // Create a new jsPDF instance
        const doc = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'a4'
        });
        
        // Add title
        doc.setFontSize(22);
        doc.setTextColor(106, 76, 147); // #6a4c93
        doc.text('Ketamine Therapy Reflection', 105, 20, { align: 'center' });
        
        // Add date
        const today = new Date();
        doc.setFontSize(12);
        doc.setTextColor(51, 51, 51); // #333333
        doc.text(`Date: ${today.toLocaleDateString()}`, 105, 30, { align: 'center' });
        
        // Add content
        let yPosition = 50;
        
        // Loop through each question and response
        for (let i = 0; i < state.sessionData.questions.length; i++) {
          // Check if we need a new page
          if (yPosition > 250) {
            doc.addPage();
            yPosition = 20;
          }
          
          // Add question number
          doc.setFontSize(16);
          doc.setFont(undefined, 'bold');
          doc.setTextColor(74, 44, 115); // #4a2c73
          doc.text(`Question ${i + 1}`, 20, yPosition);
          yPosition += 10;
          
          // Handle long questions with text wrapping
          const questionLines = doc.splitTextToSize(state.sessionData.questions[i], 170);
          doc.setFontSize(14);
          doc.setTextColor(51, 51, 51); // #333333
          doc.text(questionLines, 20, yPosition);
          yPosition += (questionLines.length * 7);
          
          // Add response
          doc.setFontSize(14);
          doc.setFont(undefined, 'bold');
          doc.text('Your Response:', 20, yPosition);
          yPosition += 10;
          
          // Handle long responses with text wrapping
          const responseLines = doc.splitTextToSize(state.sessionData.responses[i] || 'No response recorded', 170);
          doc.setFontSize(12);
          doc.setFont(undefined, 'normal');
          doc.text(responseLines, 20, yPosition);
          yPosition += (responseLines.length * 7);
          
          // Add follow-up question if available
          if (state.sessionData.followups && state.sessionData.followups[i]) {
            // Check if we need a new page
            if (yPosition > 250) {
              doc.addPage();
              yPosition = 20;
            }
            
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(52, 152, 219); // #3498db
            doc.text('AI Follow-up:', 20, yPosition);
            yPosition += 10;
            
            const followupLines = doc.splitTextToSize(state.sessionData.followups[i], 170);
            doc.setFontSize(12);
            doc.setFont(undefined, 'italic');
            doc.text(followupLines, 20, yPosition);
            yPosition += (followupLines.length * 7) + 15;
          } else {
            yPosition += 15;
          }
        }
        
        // Add footer
        const pageCount = doc.internal.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(10);
          doc.setFont(undefined, 'normal');
          doc.setTextColor(102, 102, 102); // #666666
          doc.text(`Page ${i} of ${pageCount}`, 105, 290, { align: 'center' });
        }
        
        // Save the PDF
        doc.save('ketamine-reflection.pdf');
        
        // Show success message
        showToast('PDF exported successfully', 'success');
        
      } catch (error) {
        console.error('Error exporting PDF:', error);
        exportAsText();
      }
    }

    // Export as text file (fallback)
    function exportAsText() {
      // Create a text representation of the data
      let textContent = `KETAMINE THERAPY REFLECTION\n`;
      textContent += `Date: ${new Date().toLocaleDateString()}\n\n`;
      
      // Add questions and responses
      for (let i = 0; i < state.sessionData.questions.length; i++) {
        textContent += `QUESTION ${i + 1}:\n`;
        textContent += `${state.sessionData.questions[i]}\n\n`;
        textContent += `YOUR RESPONSE:\n`;
        textContent += `${state.sessionData.responses[i] || 'No response recorded'}\n\n`;
        
        if (state.sessionData.followups && state.sessionData.followups[i]) {
          textContent += `AI FOLLOW-UP:\n`;
          textContent += `${state.sessionData.followups[i]}\n\n`;
        }
        
        textContent += `----------------------------------------\n\n`;
      }
      
      // Create a blob and download link
      const blob = new Blob([textContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `ketamine-reflection-${new Date().toISOString().split('T')[0]}.txt`;
      
      // Trigger download
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      // Show success message
      showToast('Text file exported successfully', 'success');
    }

    // Save current question and response to session data
    function saveCurrentData() {
      if (state.currentQuestion && transcriptionText.value.trim()) {
        state.transcription = transcriptionText.value.trim();
        
        // Check if this question is already in the session data
        const index = state.sessionData.questions.indexOf(state.currentQuestion);
        
        if (index === -1) {
          // Add new question and response
          state.sessionData.questions.push(state.currentQuestion);
          state.sessionData.responses.push(state.transcription);
          
          // Add follow-up if available
          if (state.followupQuestion) {
            state.sessionData.followups.push(state.followupQuestion);
          } else {
            state.sessionData.followups.push('');
          }
        } else {
          // Update existing question and response
          state.sessionData.responses[index] = state.transcription;
          
          // Update follow-up if it exists
          if (state.followupQuestion) {
            state.sessionData.followups[index] = state.followupQuestion;
          }
        }
      }
    }

    // Save the current session
    function saveSession() {
      // Save the current question and response
      saveCurrentData();
      
      if (state.sessionData.questions.length === 0) {
        showErrorMessage('No data to save. Please answer at least one question.');
        return;
      }
      
      // Generate a session ID
      const sessionId = `session_${new Date().toISOString()}`;
      
      // Create session metadata
      const sessionWithMetadata = {
        ...state.sessionData,
        metadata: {
          id: sessionId,
          timestamp: new Date().toISOString(),
          questionCount: state.sessionData.questions.length
        }
      };
      
      try {
        // Save to localStorage
        localStorage.setItem(`ketamine_${sessionId}`, JSON.stringify(sessionWithMetadata));
        
        // Update session index
        updateSessionIndex(sessionId);
        
        // Reload sessions
        loadSavedSessions();
        
        // Show success message
        showToast('Session saved successfully', 'success');
      } catch (error) {
        console.error('Error saving session:', error);
        showErrorMessage('Could not save session. Local storage may be full or disabled.');
      }
    }

    // Update the session index with the new session
    function updateSessionIndex(sessionId) {
      try {
        // Get existing index or create new one
        let sessionIndex = JSON.parse(localStorage.getItem('ketamine_session_index')) || [];
        
        // Add new session if not already in index
        if (!sessionIndex.includes(sessionId)) {
          sessionIndex.push(sessionId);
          localStorage.setItem('ketamine_session_index', JSON.stringify(sessionIndex));
        }
      } catch (error) {
        console.error('Error updating session index:', error);
      }
    }

    // Load saved sessions from localStorage
    function loadSavedSessions() {
      try {
        // Get session index
        const sessionIndex = JSON.parse(localStorage.getItem('ketamine_session_index')) || [];
        
        // Load metadata for each session
        state.sessionHistory.sessions = sessionIndex.map(sessionId => {
          try {
            const sessionData = JSON.parse(localStorage.getItem(`ketamine_${sessionId}`));
            return sessionData ? sessionData.metadata : null;
          } catch (error) {
            return null;
          }
        }).filter(Boolean); // Remove any null values
        
        // Update the session list UI
        updateSessionList();
      } catch (error) {
        console.error('Error loading sessions:', error);
      }
    }

    // Update the session list in the UI
    function updateSessionList() {
      // Clear the list
      sessionList.innerHTML = '';
      
      // Show empty message if no sessions
      if (state.sessionHistory.sessions.length === 0) {
        sessionList.innerHTML = '<p class="empty-message">No saved sessions found.</p>';
        return;
      }
      
      // Sort sessions by timestamp (newest first)
      const sortedSessions = [...state.sessionHistory.sessions].sort((a, b) => {
        return new Date(b.timestamp) - new Date(a.timestamp);
      });
      
      // Create a list item for each session
      sortedSessions.forEach(session => {
        const sessionDate = new Date(session.timestamp).toLocaleDateString();
        const sessionTime = new Date(session.timestamp).toLocaleTimeString();
        
        const sessionItem = document.createElement('div');
        sessionItem.className = 'session-item';
        sessionItem.innerHTML = `
          <div class="session-info">
            <h4>${session.id.replace('session_', '').substring(0, 10)}...</h4>
            <p>${sessionDate} at ${sessionTime}</p>
            <p>${session.questionCount} question${session.questionCount !== 1 ? 's' : ''}</p>
          </div>
          <div class="session-actions">
            <button class="btn small-btn load-session-btn" data-id="${session.id}">
              <i class="fas fa-folder-open"></i> Load
            </button>
            <button class="btn small-btn delete-session-btn" data-id="${session.id}">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        
        // Add event listeners
        const loadBtn = sessionItem.querySelector('.load-session-btn');
        loadBtn.addEventListener('click', () => loadSession(session.id));
        
        const deleteBtn = sessionItem.querySelector('.delete-session-btn');
        deleteBtn.addEventListener('click', () => deleteSession(session.id));
        
        sessionList.appendChild(sessionItem);
      });
    }

    // Load a session
    function loadSession(sessionId) {
      try {
        // Get the session data
        const sessionData = JSON.parse(localStorage.getItem(`ketamine_${sessionId}`));
        
        if (!sessionData) {
          showErrorMessage('Could not load session. It may have been deleted or corrupted.');
          return;
        }
        
        // Update state
        state.sessionData = {
          questions: sessionData.questions || [],
          responses: sessionData.responses || [],
          followups: sessionData.followups || []
        };
        
        // Hide session history
        hideSessionHistory();
        
        // Show confirmation
        showToast('Session loaded successfully', 'success');
        
        // If there are questions in the session, load the first one
        if (sessionData.questions && sessionData.questions.length > 0) {
          // Load the first question
          state.currentQuestion = sessionData.questions[0];
          currentQuestionEl.textContent = state.currentQuestion;
          
          // Load the response if available
          if (sessionData.responses && sessionData.responses.length > 0) {
            state.transcription = sessionData.responses[0];
            transcriptionText.value = state.transcription;
          }
          
          // Load the follow-up if available
          if (sessionData.followups && sessionData.followups.length > 0) {
            state.followupQuestion = sessionData.followups[0];
            followupText.textContent = state.followupQuestion || 'AI follow-up question will appear here after generation...';
          }
          
          // Enable buttons
          recordBtn.disabled = false;
          editTranscriptionBtn.disabled = false;
          aiFollowupBtn.disabled = false;
          exportPdfBtn.disabled = false;
          saveSessionBtn.disabled = false;
        }
      } catch (error) {
        console.error('Error loading session:', error);
        showErrorMessage('Could not load session. It may be corrupted.');
      }
    }

    // Delete a session
    function deleteSession(sessionId) {
      // Confirm deletion
      if (!confirm('Are you sure you want to delete this session? This cannot be undone.')) {
        return;
      }
      
      try {
        // Remove from localStorage
        localStorage.removeItem(`ketamine_${sessionId}`);
        
        // Update session index
        let sessionIndex = JSON.parse(localStorage.getItem('ketamine_session_index')) || [];
        sessionIndex = sessionIndex.filter(id => id !== sessionId);
        localStorage.setItem('ketamine_session_index', JSON.stringify(sessionIndex));
        
        // Reload sessions
        loadSavedSessions();
        
        // Show confirmation
        showToast('Session deleted successfully', 'success');
      } catch (error) {
        console.error('Error deleting session:', error);
        showErrorMessage('Could not delete session. Please try again.');
      }
    }

    // Toggle session history visibility
    function toggleSessionHistory() {
      if (state.sessionHistory.visible) {
        hideSessionHistory();
      } else {
        showSessionHistory();
      }
    }

    // Show session history
    function showSessionHistory() {
      // Reload sessions
      loadSavedSessions();
      
      // Show the container
      sessionHistoryPanel.classList.add('visible');
      state.sessionHistory.visible = true;
    }

    // Hide session history
    function hideSessionHistory() {
      // Hide the container
      sessionHistoryPanel.classList.remove('visible');
      state.sessionHistory.visible = false;
    }

    // Export all sessions
    function exportAllSessions() {
      try {
        // Get all sessions
        const sessions = {};
        const sessionIndex = JSON.parse(localStorage.getItem('ketamine_session_index')) || [];
        
        if (sessionIndex.length === 0) {
          showErrorMessage('No sessions to export.');
          return;
        }
        
        // Load each session
        sessionIndex.forEach(sessionId => {
          const sessionData = JSON.parse(localStorage.getItem(`ketamine_${sessionId}`));
          if (sessionData) {
            sessions[sessionId] = sessionData;
          }
        });
        
        // Create JSON blob
        const jsonBlob = new Blob([JSON.stringify(sessions, null, 2)], { type: 'application/json' });
        
        // Create download link
        const url = URL.createObjectURL(jsonBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `ketamine-sessions-${new Date().toISOString().split('T')[0]}.json`;
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        // Show confirmation
        showToast('All sessions exported successfully', 'success');
      } catch (error) {
        console.error('Error exporting sessions:', error);
        showErrorMessage('Could not export sessions. Please try again.');
      }
    }
    
    // Format and copy the current question and response as a note
    function copyAsNote() {
      // Get the current question and response
      const question = state.currentQuestion;
      const response = transcriptionText.value.trim();
      const followup = state.followupQuestion;
      
      if (!question || !response) {
        showErrorMessage('Please select a question and provide a response first.');
        return;
      }
      
      // Format the note
      let noteContent = `<h4>Question:</h4>\n<p>${question}</p>\n\n<h4>Response:</h4>\n<p>${response}</p>`;
      
      // Add follow-up if available
      if (followup) {
        noteContent += `\n\n<div class="followup"><h4>Follow-up Question:</h4>\n<p>${followup}</p></div>`;
      }
      
      // Add date
      const date = new Date().toLocaleDateString();
      const timestamp = new Date().toISOString();
      noteContent += `\n\n<p><em>Date: ${date}</em></p>`;
      
      // Display the formatted note
      const noteSection = document.querySelector('.note-section');
      const noteContentEl = document.getElementById('note-content');
      
      noteContentEl.innerHTML = noteContent;
      noteSection.style.display = 'block';
      
      // Create a note object
      const noteObject = {
        id: `note_${timestamp}`,
        question: question,
        response: response,
        followup: followup || '',
        timestamp: timestamp,
        date: date
      };
      
      // Save note to localStorage
      saveNote(noteObject);
      
      // Copy to clipboard
      const plainTextNote = `Question:\n${question}\n\nResponse:\n${response}${followup ? '\n\nFollow-up Question:\n' + followup : ''}\n\nDate: ${date}`;
      
      navigator.clipboard.writeText(plainTextNote)
        .then(() => {
          // Show success message
          showToast('Note copied to clipboard and saved!', 'success');
          
          // Scroll to the note section
          noteSection.scrollIntoView({ behavior: 'smooth' });
        })
        .catch(err => {
          console.error('Could not copy text: ', err);
          showToast('Note saved but clipboard copy failed. You can copy manually.', 'warning');
        });
    }
    
    // Save a note to localStorage
    function saveNote(noteObject) {
      try {
        // Get existing notes or create new array
        let notes = JSON.parse(localStorage.getItem('ketamine_notes')) || [];
        
        // Add new note
        notes.push(noteObject);
        
        // Save back to localStorage
        localStorage.setItem('ketamine_notes', JSON.stringify(notes));
        
        // Update state
        state.notes.items = notes;
        
        // Update notes button count
        updateNotesButtonCount();
        
        return true;
      } catch (error) {
        console.error('Error saving note:', error);
        return false;
      }
    }
    
    // Get all saved notes
    function getAllNotes() {
      try {
        return JSON.parse(localStorage.getItem('ketamine_notes')) || [];
      } catch (error) {
        console.error('Error getting notes:', error);
        return [];
      }
    }

    // Show import dialog
    function showImportDialog() {
      // Create a file input
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'application/json';
      
      // Set up the change event
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        // Read the file
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            // Parse the JSON
            const sessionsData = JSON.parse(e.target.result);
            
            // Import the sessions
            let importCount = 0;
            
            // Import each session
            Object.entries(sessionsData).forEach(([sessionId, sessionData]) => {
              localStorage.setItem(`ketamine_${sessionId}`, JSON.stringify(sessionData));
              updateSessionIndex(sessionId);
              importCount++;
            });
            
            if (importCount > 0) {
              // Reload sessions
              loadSavedSessions();
              
              // Show confirmation
              showToast(`Successfully imported ${importCount} session(s)`, 'success');
            } else {
              showErrorMessage('No sessions were imported. The file may be invalid or empty.');
            }
          } catch (error) {
            console.error('Error importing sessions:', error);
            showErrorMessage('Could not import sessions. The file may be invalid or corrupted.');
          }
        };
        
        reader.readAsText(file);
      });
      
      // Trigger the file input
      fileInput.click();
    }
    
    // Toggle notes panel visibility
    function toggleNotesPanel() {
      const notesPanel = document.getElementById('notes-panel');
      
      if (notesPanel.classList.contains('visible')) {
        hideNotesPanel();
      } else {
        // Hide session history if visible
        hideSessionHistory();
        
        // Show notes panel
        notesPanel.classList.add('visible');
        
        // Load and display notes
        loadAndDisplayNotes();
      }
    }
    
    // Hide notes panel
    function hideNotesPanel() {
      const notesPanel = document.getElementById('notes-panel');
      notesPanel.classList.remove('visible');
    }
    
    // Load and display notes
    function loadAndDisplayNotes() {
      // Clear search input
      const searchInput = document.getElementById('notes-search-input');
      if (searchInput) {
        searchInput.value = '';
      }
      
      // Get all notes and display them
      const notes = getAllNotes();
      displayNotes(notes);
    }
    
    // Truncate text to a specific length
    function truncateText(text, maxLength) {
      if (!text) return '';
      return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
    }
    
    // Copy a note by ID
    function copyNoteById(noteId) {
      const notes = getAllNotes();
      const note = notes.find(n => n.id === noteId);
      
      if (!note) {
        showErrorMessage('Note not found.');
        return;
      }
      
      // Format the note for clipboard
      const plainTextNote = `Question:\n${note.question}\n\nResponse:\n${note.response}${note.followup ? '\n\nFollow-up Question:\n' + note.followup : ''}\n\nDate: ${note.date}`;
      
      // Copy to clipboard
      navigator.clipboard.writeText(plainTextNote)
        .then(() => {
          showToast('Note copied to clipboard!', 'success');
        })
        .catch(err => {
          console.error('Could not copy text: ', err);
          showErrorMessage('Failed to copy to clipboard. Please try again.');
        });
    }
    
    // Delete a note
    function deleteNote(noteId) {
      // Confirm deletion
      if (!confirm('Are you sure you want to delete this note?')) {
        return;
      }
      
      try {
        // Get existing notes
        let notes = getAllNotes();
        
        // Filter out the note to delete
        notes = notes.filter(note => note.id !== noteId);
        
        // Save back to localStorage
        localStorage.setItem('ketamine_notes', JSON.stringify(notes));
        
        // Update state
        state.notes.items = notes;
        
        // Update notes button count
        updateNotesButtonCount();
        
        // Reload notes
        loadAndDisplayNotes();
        
        // Show confirmation
        showToast('Note deleted successfully', 'success');
      } catch (error) {
        console.error('Error deleting note:', error);
        showErrorMessage('Could not delete note. Please try again.');
      }
    }
    
    // Export all notes
    function exportAllNotes() {
      try {
        // Get all notes
        const notes = getAllNotes();
        
        if (notes.length === 0) {
          showErrorMessage('No notes to export.');
          return;
        }
        
        // Create JSON blob
        const jsonBlob = new Blob([JSON.stringify(notes, null, 2)], { type: 'application/json' });
        
        // Create download link
        const url = URL.createObjectURL(jsonBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `ketamine-notes-${new Date().toISOString().split('T')[0]}.json`;
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        // Show confirmation
        showToast('All notes exported successfully', 'success');
      } catch (error) {
        console.error('Error exporting notes:', error);
        showErrorMessage('Could not export notes. Please try again.');
      }
    }
    
    // Clear all notes
    function clearAllNotes() {
      // Confirm deletion
      if (!confirm('Are you sure you want to delete ALL notes? This cannot be undone.')) {
        return;
      }
      
      try {
        // Clear notes from localStorage
        localStorage.removeItem('ketamine_notes');
        
        // Update state
        state.notes.items = [];
        
        // Update notes button count
        updateNotesButtonCount();
        
        // Reload notes
        loadAndDisplayNotes();
        
        // Show confirmation
        showToast('All notes cleared successfully', 'success');
      } catch (error) {
        console.error('Error clearing notes:', error);
        showErrorMessage('Could not clear notes. Please try again.');
      }
    }
    
    // Import notes from a JSON file
    function importNotes() {
      // Create a file input
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'application/json';
      
      // Set up the change event
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        // Read the file
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            // Parse the JSON
            const importedNotes = JSON.parse(e.target.result);
            
            if (!Array.isArray(importedNotes)) {
              showErrorMessage('Invalid notes format. Expected an array of notes.');
              return;
            }
            
            // Get existing notes
            let currentNotes = getAllNotes();
            
            // Add imported notes
            const newNotes = [...currentNotes, ...importedNotes];
            
            // Save back to localStorage
            localStorage.setItem('ketamine_notes', JSON.stringify(newNotes));
            
            // Update state
            state.notes.items = newNotes;
            
            // Update notes button count
            updateNotesButtonCount();
            
            // Reload notes
            loadAndDisplayNotes();
            
            // Show confirmation
            showToast(`Successfully imported ${importedNotes.length} note(s)`, 'success');
          } catch (error) {
            console.error('Error importing notes:', error);
            showErrorMessage('Could not import notes. The file may be invalid or corrupted.');
          }
        };
        
        reader.readAsText(file);
      });
      
      // Trigger the file input
      fileInput.click();
    }
    
    // Search notes
    function searchNotes(query) {
      if (!query || query.trim() === '') {
        // If no query, show all notes
        loadAndDisplayNotes();
        return;
      }
      
      // Get all notes
      const allNotes = getAllNotes();
      
      // Convert query to lowercase for case-insensitive search
      const lowerQuery = query.toLowerCase();
      
      // Filter notes that match the query
      const filteredNotes = allNotes.filter(note => {
        return (
          note.question.toLowerCase().includes(lowerQuery) ||
          note.response.toLowerCase().includes(lowerQuery) ||
          (note.followup && note.followup.toLowerCase().includes(lowerQuery))
        );
      });
      
      // Display filtered notes
      displayNotes(filteredNotes);
      
      // Show search results message
      const notesList = document.getElementById('notes-list');
      if (filteredNotes.length === 0) {
        // If no results, show message
        notesList.innerHTML = `<p class="empty-message">No notes found matching "${query}"</p>`;
      } else {
        // Show search results count at the top
        const resultsMessage = document.createElement('div');
        resultsMessage.className = 'search-results-message';
        resultsMessage.innerHTML = `Found ${filteredNotes.length} note(s) matching "${query}" <button id="clear-search-btn" class="btn small-btn">Clear Search</button>`;
        notesList.insertBefore(resultsMessage, notesList.firstChild);
        
        // Add event listener to clear search button
        document.getElementById('clear-search-btn').addEventListener('click', () => {
          document.getElementById('notes-search-input').value = '';
          loadAndDisplayNotes();
        });
      }
    }
    
    // Display notes (either all or filtered)
    function displayNotes(notes) {
      const notesList = document.getElementById('notes-list');
      
      // Clear the list
      notesList.innerHTML = '';
      
      // Show empty message if no notes
      if (notes.length === 0) {
        notesList.innerHTML = '<p class="empty-message">No saved notes found.</p>';
        return;
      }
      
      // Sort notes by timestamp (newest first)
      const sortedNotes = [...notes].sort((a, b) => {
        return new Date(b.timestamp) - new Date(a.timestamp);
      });
      
      // Create a list item for each note
      sortedNotes.forEach(note => {
        const noteItem = document.createElement('div');
        noteItem.className = 'note-item';
        
        let noteContent = `
          <h4>${truncateText(note.question, 50)}</h4>
          <p>${truncateText(note.response, 100)}</p>
        `;
        
        if (note.followup) {
          noteContent += `<div class="note-followup">${truncateText(note.followup, 80)}</div>`;
        }
        
        noteContent += `<div class="note-date">${note.date}</div>`;
        
        noteContent += `
          <div class="note-actions">
            <button class="btn small-btn copy-note-btn" data-id="${note.id}">
              <i class="fas fa-copy"></i> Copy
            </button>
            <button class="btn small-btn delete-note-btn" data-id="${note.id}">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        
        noteItem.innerHTML = noteContent;
        
        // Add event listeners
        const copyBtn = noteItem.querySelector('.copy-note-btn');
        copyBtn.addEventListener('click', () => copyNoteById(note.id));
        
        const deleteBtn = noteItem.querySelector('.delete-note-btn');
        deleteBtn.addEventListener('click', () => deleteNote(note.id));
        
        notesList.appendChild(noteItem);
      });
    }

    // Start recording timer
    function startRecordingTimer() {
      state.recordingStartTime = Date.now();
      state.recordingTimer = setInterval(updateRecordingTime, 1000);
    }

    // Stop recording timer
    function stopRecordingTimer() {
      if (state.recordingTimer) {
        clearInterval(state.recordingTimer);
        state.recordingTimer = null;
      }
    }

    // Update recording time display
    function updateRecordingTime() {
      if (!state.recordingStartTime) return;
      
      const elapsedSeconds = Math.floor((Date.now() - state.recordingStartTime) / 1000);
      const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
      const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
      
      recordingTime.textContent = `${minutes}:${seconds}`;
    }

    // Show error message
    function showErrorMessage(message) {
      showToast(message, 'error');
    }

    // Show toast notification
    function showToast(message, type = 'info') {
      // Create toast container if it doesn't exist
      let toastContainer = document.getElementById('toast-container');
      
      if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toast-container';
        document.body.appendChild(toastContainer);
      }
      
      // Create toast element
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <div class="toast-content">
          <p>${message}</p>
        </div>
      `;
      
      // Add to container
      toastContainer.appendChild(toast);
      
      // Show the toast
      setTimeout(() => {
        toast.classList.add('show');
      }, 10);
      
      // Remove after delay
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          toastContainer.removeChild(toast);
        }, 300);
      }, 3000);
    }

    // Initialize the application when the DOM is loaded
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>